---
title: "API Introduction"
description: "This is a merchant-facing API that supports stablecoin on-ramp and off-ramp transactions. We provide REST API with OAuth 2.0 for authorization."
---

## General Information

Below are the details for the Sandbox and Live URLs for onramp and off-ramp Transaction in Durianpay:

- Production Base URL: https://api.durian-x.com/v1.0
- Sandbox Base URL: https://api-sandbox.durian-x.com/v1.0

## Authentication

### Credential Setup

Follow steps below, to use mTLS authentication with Durianpay's API

1. **Generate Private Key and Certificate Signing Request**

```shellscript
openssl genrsa -out ca.key 4096
openssl req -new -x509 -days 365 -key ca.key -out ca.crt -subj "/C=US/ST=CA/L=SF/O=RSA-2048 CA/OU=IT/CN=My Root RSA 4096 CA"

openssl genrsa -out client.key 4096
cat > client.ext <<EOF
authorityKeyIdentifier=keyid,issuer
basicConstraints=CA:FALSE
keyUsage=digitalSignature, keyEncipherment
extendedKeyUsage=clientAuth
subjectAltName=DNS:localhost
EOF
openssl req -new -key client.key -out client.csr -subj "/C=US/ST=CA/L=SF/O=MyOrg/OU=MyOU/CN=MyClient"
openssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out client.crt -days 365 -extfile client.ext
```

2. Send your public key via e-mail to [support@durian-x.com](mailto:support@durian-x.com)
3. We will give you following password encrypted credential to connect with:
   1. **Client ID (X-Client-ID)**: Your autogenerated Client ID
   2. **Client Secret Key:** Your secret key will be use to generate signature for transactional API

### **Generate Signature To Obtain Access Token (B2B)**

```json
<X-CLIENT-ID>|<X-TIMESTAMP> // (on ISO8601 format)
//Example: mer_123123|2024-05-13T14:53:06.991+07:00
```

which then signed using SHA256withRSA with Private Key and Client Certificate shared by Durianpay to merchant.

```json
X-Signature: aw3o6HM68vJDLO4nxAPgK0it5nd6zik3bUgMzqLiTrIB7w1QbnCLDo/IMVjaYsbPk9s=
```

- Sample Code - Go

  ```go
  package main
  
  import (
  	"crypto"
  	"crypto/rand"
  	"crypto/rsa"
  	"crypto/sha256"
  	"crypto/x509"
  	"encoding/base64"
  	"encoding/pem"
  	"fmt"
  	"io/ioutil"
  	"log"
  	"time"
  )
  
  // Custom timestamp formatter like Postman's script
  func toIsoString(t time.Time) string {
  	_, offset := t.Zone()
  	sign := "+"
  	if offset < 0 {
  		sign = "-"
  		offset = -offset
  	}
  	hours := offset / 3600
  	minutes := (offset % 3600) / 60
  
  	return fmt.Sprintf("%04d-%02d-%02dT%02d:%02d:%02d.%03d%s%02d:%02d",
  		t.Year(), t.Month(), t.Day(),
  		t.Hour(), t.Minute(), t.Second(), t.Nanosecond()/1e6,
  		sign, hours, minutes,
  	)
  }
  
  func main() {
  	// === CHANGE THIS ===
  	clientID := "your-client-id"
  	privateKeyPath := "./rsa_private_key.pem"
  
  	// Generate timestamp
  	timestamp := toIsoString(time.Now())
  	fmt.Println("Timestamp:", timestamp)
  
  	// Read and parse private key
  	privKeyBytes, err := ioutil.ReadFile(privateKeyPath)
  	if err != nil {
  		log.Fatalf("Failed to read private key file: %v", err)
  	}
  
  	block, _ := pem.Decode(privKeyBytes)
  	if block == nil || (block.Type != "PRIVATE KEY" && block.Type != "RSA PRIVATE KEY") {
  		log.Fatal("Failed to decode PEM block containing private key")
  	}
  
  	var privKey *rsa.PrivateKey
  	if block.Type == "PRIVATE KEY" {
  		key, err := x509.ParsePKCS8PrivateKey(block.Bytes)
  		if err != nil {
  			log.Fatalf("Failed to parse PKCS8 private key: %v", err)
  		}
  		privKey = key.(*rsa.PrivateKey)
  	} else {
  		key, err := x509.ParsePKCS1PrivateKey(block.Bytes)
  		if err != nil {
  			log.Fatalf("Failed to parse PKCS1 private key: %v", err)
  		}
  		privKey = key
  	}
  
  	// Create data to sign
  	data := clientID + "|" + timestamp
  	hashed := sha256.Sum256([]byte(data))
  
  	// Sign the hash
  	signature, err := rsa.SignPKCS1v15(rand.Reader, privKey, crypto.SHA256, hashed[:])
  	if err != nil {
  		log.Fatalf("Failed to sign data: %v", err)
  	}
  
  	// Encode in base64
  	sigBase64 := base64.StdEncoding.EncodeToString(signature)
  	fmt.Println("Signature (Base64):", sigBase64)
  }
  
  ```

### Generate Signature for Transactional API

You can find the required structure of the string to be encrypted as below:

```json
<HTTP METHOD> + ":" + <RELATIVE PATH URL> + ":" + <B2B ACCESS TOKEN> + ":" + LowerCase(HexEncode(SHA-256(Minify(<HTTP BODY>)))) + ":" + <X-TIMESTAMP>
  // Example: POST:/v1.0/balance-inquiry:eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJEdXJpYW4gTW9uZXkiLC :f806c49e8cd175aa9dd5dd8e0a49648c885954d:2024-05-13T15:07:07+07:00
```

which then encrypted using HMAC-SHA512 with merchant's Secret Key that Durianpay gave.

```http
X-Signature: tnNHFw5ZCWjnHFd9UGAB5iDLuwo+89efml8F1CP8vaqut/PfNWac/XLiCkLt3zGHTppZKPxz/PPptqM2alsOFA==
```

### **Validate Webhook Signature**

You can find the required structure of the string to be decrypt as below:

```go
<HTTP METHOD> + ":" + <RELATIVE PATH URL> + ":" + LowerCase(HexEncode(SHA-256(Minify(<H
TTP BODY>)))) + ":" + <X-TIMESTAMP>
  // Example: POST:/v1.0/balance-inquiry::f806c49e8cd175aa9dd5dd8e0a49648c885954d:2024-05-13T15:07:07+07:00
```

For example:

Given your webhook URL is https://merchant.com/webhook/asset-deposit and the header and payload as follows

```
HTTP Header:
X-Timestamp: 2025-12-15T10:49:49.971172Z

Request Payload:
{
	"id":"019b0b0b-76a0-744d-ba52-682ccde1f211",
	"merchantId":"mer_123",
	"accountId":"1512630d-f6c1-489b-a957-da5b93df9807",
	"address":"0x06978f1b3b281827d7d65501f94c0b9affd7bb43",
	"amount":"10.1",
	"network":"ERC20",
	"status":"completed",
	"asset":"USDT",
	"txnHash":"0xb4f063ded48ddc4d8236d45b33bd6e4ce18afebc113fc4fd0a5fd439b862cc5b",
	"createdAt":"2025-12-15T10:49:49.971172Z",
	"finalStatusAt":"2025-12-15T10:49:49.971172Z",
	"reason":"successful"
}
```

Then the string to sign would be:

```
POST:/webhook/asset-deposit:f9a8c7e6d5b4a3f2e1d0c9b8a7f6e5d4c3b2a1f0e9d8c7b6a5f4e3d2c1b0a9f8:2025-12-15T10:49:49.971+00:00
```

Where:

- `POST` is the HTTP method
- `/webhook/asset-deposit` is the relative path (without the domain)
- `f9a8c7e6d5b4a3f2e1d0c9b8a7f6e5d4c3b2a1f0e9d8c7b6a5f4e3d2c1b0a9f8` is the lowercase hex-encoded SHA-256 hash of the minified JSON payload
- `2024-05-13T15:07:07+07:00` is the X-Timestamp value from the webhook request header

To validate the signature:

1. Compute SHA-256 hash of the minified request body
2. Convert the hash to lowercase hexadecimal string
3. Construct the string: `HTTP_METHOD:RELATIVE_PATH:HASH:X_TIMESTAMP`
4. Compute HMAC-SHA512 of this string using your Secret Key
5. Base64 encode the result
6. Compare with the X-Signature header value from the webhook request

- Sample Code - Go

  ```
  package main
  
  import (
  	"crypto/hmac"
  	"crypto/sha256"
  	"crypto/sha512"
  	"encoding/base64"
  	"encoding/hex"
  	"encoding/json"
  	"fmt"
  	"log"
  )
  
  func main() {
  	// Webhook details
  	httpMethod := "POST"
  	relativePath := "/webhook/asset-deposit"
  	timestamp := "2025-12-15T10:49:49.971+00:00"
  	secretKey := "your-secret-key" // Replace with your actual secret key
  	
  	// Sample payload
  	payload := map[string]interface{}{
  		"id":            "019b0b0b-76a0-744d-ba52-682ccde1f211",
  		"merchantId":    "mer_123",
  		"accountId":     "1512630d-f6c1-489b-a957-da5b93df9807",
  		"address":       "0x06978f1b3b281827d7d65501f94c0b9affd7bb43",
  		"amount":        "10.1",
  		"network":       "ERC20",
  		"status":        "completed",
  		"asset":         "USDT",
  		"txnHash":       "0xb4f063ded48ddc4d8236d45b33bd6e4ce18afebc113fc4fd0a5fd439b862cc5b",
  		"createdAt":     "2025-12-15 10:49:49.971172 +0000 UTC",
  		"finalStatusAt": "2025-12-15 10:49:49.971172 +0000 UTC",
  		"reason":        "successful",
  	}
  	
  	// Minify JSON
  	minified, err := json.Marshal(payload)
  	if err != nil {
  		log.Fatalf("Failed to marshal payload: %v", err)
  	}
  	
  	// Compute SHA-256 hash
  	hash := sha256.Sum256(minified)
  	hashHex := hex.EncodeToString(hash[:])
  	
  	// Construct string to sign
  	stringToSign := fmt.Sprintf("%s:%s:%s:%s", httpMethod, relativePath, hashHex, timestamp)
  	fmt.Println("String to sign:", stringToSign)
  	
  	// Generate HMAC-SHA512 signature
  	mac := hmac.New(sha512.New, []byte(secretKey))
  	mac.Write([]byte(stringToSign))
  	signature := mac.Sum(nil)
  	
  	// Base64 encode
  	signatureBase64 := base64.StdEncoding.EncodeToString(signature)
  	fmt.Println("X-Signature:", signatureBase64)
  }
  
  ```

## General Request and Response Format

### **Request Header**

Each Request requires specific header value. There are 2 kind of header for requests, to generate Access Token, and do Transaction

**Access Token Header**

| **Header**   | **Description**            | **Format**            |
| :----------- | :------------------------- | :-------------------- |
| X-Timestamp  | Request timestamp ISO 8601 | datetime              |
| X-Signature  | Security signature         | Base64 encoded string |
| X-Client-ID  | Merchant Client ID         | String                |
| Content-Type | Type of data being sent    | MIME type             |

**Transaction Request Header**\
For On-ramp and Off-ramp Transaction we will check only for following request headers

| **Header**        | **Description**                                                                                      | **Format**                       |
| :---------------- | :--------------------------------------------------------------------------------------------------- | :------------------------------- |
| X-Timestamp       | Request timestamp                                                                                    | ISO 8601 datetime                |
| X-Signature       | Security signature                                                                                   | Base64 encoded string            |
| X-Idempotency-Key | Unique messaging reference identifier generated by merchant and should be unique within the same day | Random Alphanumeric string       |
| Content-Type      | Type of data being sent                                                                              | MIME type (use application/json) |
| Authorization     | Authorization token                                                                                  | JWT (Started with 'Bearer ')     |

**Response Definition**

- **Format**

  HTTP code response in Durianpay is following the standard defined byÂ [RFC 9110](https://httpwg.org/specs/rfc9110.html#overview.of.status.codes). Example: When doing request of swap transaction with the same X-External-ID twice, merchant will receive error with code 409 where:
  - 409 is HTTP code for Conflict
  - 00 together with 409 HTTP code indicates same X-External-ID or partnerReferenceNo is being used twice.Reference
- **Response Code List**

  Please refer to table below for list of Response Code, Response Message, and its meaning.
  - **Successful Response**

  | **HTTP Code** | **Case Code** | **Response Message** | **Description**                             |
  | :------------ | :------------ | :------------------- | :------------------------------------------ |
  | 200           | SUCCESS       | Successful           | General Successful Result                   |
  | 201           | CREATED       | Resource Created     | Successsful                                 |
  | 202           | ACCEPTED      | Request Accepted     | Successful but transaction still on process |
  - **Error Response**

    | **HTTP Code** | **Case Code**      | **Response Message**                                  | **Description**                                                                                                                                                                       |
    | :------------ | :----------------- | :---------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
    | 400           | BAD_REQUEST        | Bad Request                                           | General request failed error, including message parsing failed.                                                                                                                       |
    | 400           | VALIDATION_ERROR   | Invalid Field Format or Value                         | Invalid format                                                                                                                                                                        |
    | 401           | UNAUTHORIZED       | Unauthorized [reason]                                 | General unauthorized error (No Interface Def, API is Invalid, Oauth Failed, Verify Client Secret Fail, Client Forbidden Access API, Unknown Client, Key not Found, Invalid Signature) |
    | 403           | TRANSACTIONEXPIRED | Transaction Expired                                   | Transaction expired                                                                                                                                                                   |
    | 403           | INACTIVE_ACCOUNT   | Inactive Account/Customer                             | Indicates inactive account                                                                                                                                                            |
    | 404           | NOT_FOUND          | Entity or Transaction Not Found                       | Transaction not found                                                                                                                                                                 |
    | 409           | CONFLICT           | Transaction already processed or Transaction Conflict | Cannot use same X-EXTERNAL-ID in same day                                                                                                                                             |
    | 500           | GENERAL_ERROR      | General Error                                         | General Error                                                                                                                                                                         |
    | 500           | INTERNAL_ERROR     | Internal Server Error                                 | Unknown Internal Server Failure, Please inquiry the status or retry the process again                                                                                                 |
    | 504           | TIMEOUT            | Timeout                                               | Timeout from the issue096                                                                                                                                                             |